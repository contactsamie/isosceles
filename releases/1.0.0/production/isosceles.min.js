/*! isosceles.js v1.0.0 | (c) 2013, Samuel Bamgboye*/
/**
 * isosceles v1.0.0 - Cleaner JavaScript Dependency Injection Factory
 *
 * Copyright 2013 Samuel Bamgboye
 * Released under the MIT license.
 */
(function (e) { var t = function (e) { }; t.defineConsole = function (e) { console = typeof e === "function" ? e : console }; console || t.defineConsole(function () { }); t.log = function (e) { console.log(e) }; t.warn = function (e) { console.warn(e) }; t.error = function (e) { console.error(e) }; t.doc = function (e, n) { if (e) { if (n) { t.doc.list = t.doc.list || {}; t.doc.list[e] = n; console.log(e + ":" + n) } else { return t.doc.list[e] || "No documentation exist for '" + e + "' at the moment" } } else { return t.doc.list } }; var n = {}; var r = {}; e.isosceles = function (i, s) { t.doc("isosceles", " isosceles is a JAVASCRIPT DEPENDENCY INJECTION FACTORY, you can define namespaces which contain modules, which contain plugins and modules from one namespace are forever separated from modules of another namespace"); if (i) { r[i] = r[i] || {}; n[i] = []; var o = n[i]; e.isosceles.namespaces = e.isosceles.namespaces || {}; if (typeof s !== "function") { s = function () { return [] } } var u = function () { }; u.prototype.module = function (n, u) { t.doc("isosceles.module", " isosceles.module is used to define a module off of a namespace. so after you have defined a namespace, you can use its module method to create modules for it"); var a = n; var f = i.toString(); u = u || []; var l = l || {}; var c = c || {}; l.namespaces = l.namespaces || {}; l.namespaces[f] = l.namespaces[f] || {}; l.namespaces[f][a] = l.namespaces[f][a] || {}; c.namespaces = c.namespaces || {}; c.namespaces[f] = c.namespaces[f] || {}; c.namespaces[f][a] = c.namespaces[f][a] || {}; var h = function (t, n) { var r = e.isosceles("_$mockObj$_").module("_$mockObj$_"); r.plugin(t, function () { return function () { return n } }); return r.using(t) }; var p = { setMockObject: function (e) { t.doc("isosceles.setMockObject", " isosceles.setMockObject is used to mosk dependencies with  supplied object containing 'dependency_name - mock' pairs . it can be used for specifying mock ina single location"); if (e) { for (var n in e) { if (e.hasOwnProperty(n)) { this.mock(n, e[n]) } } } return this }, testSetUp: function (e, t, n) { this.setMockObject(n); if (e && t !== undefined) { this.expect(e, t) } return this }, getExpectation: function (e) { return c.namespaces[f][a][e] }, test: function (e, n, r) { r = r || n; if (e && typeof r === "function") { var i = false; var s = ""; t.warn("Testing " + e + "***********"); var o = this.using(e)(n || undefined); var u = c.namespaces[f][a][e]; if (typeof u === "function") { var l = u && u(); i = o === l; s = u && u["note"] || ""; r(i, s, o, l) } else { t.error("Testing " + e + " was unsuccessfull!"); r() } } return this }, expect: function (e, t, n) { if (e) { c.namespaces[f][a][e] = function () { return t }; c.namespaces[f][a][e]["note"] = n || "" } return this }, specify: function () { }, getMockObject: function (e) { var t = l.namespaces[f][a][e]; var n = typeof t === "function" ? t : undefined; return n }, isMocked: function (e) { return this.getMockObject(e) ? true : false }, enableMocking: true, mock: function (e, t) { if (e && t !== undefined) { l.namespaces[f][a][e] = function () { return h(e, t) } } return this }, using: function (e) { if (e) { var n = o.length; t.log("searching for plugin   " + e + " in pile ......"); for (var r = 0; r < n; r++) { if (o[r].name === e) { var i = this; t.log("found plugin   " + e + "! now returning ... "); var s = function (e, t, n) { return s.WithArguments(e, t).execute(n || undefined) }; s.WithArguments = function (e, n) { return { execute: function (s) { var u = function (e) { var t = u[e]; if (e && t) { return t } else { throw "unable to inject dependency '" + (e || "") + "' into '" + o[r].name + "' Plugin  in module '" + o[r].module + "'" } }; var a = i.enableMocking && i.getMockObject(o[r].name); a || i.dependencyInjectorFactory(r, u, s, e); var f = typeof n === "function" ? n : function () { }; var l = a ? a() : o[r].plugin(u); if (typeof l === "function") { try { var c = l(e, f); return c } catch (h) { t.error(o[r].name + " Plugin  in module " + o[r].module + " threw an exception ..." + h + "  " + o[r].plugin) } } else { t.error(o[r].name + " Plugin  in module " + o[r].module + " did not return a function"); t.error(o[r].plugin) } } } }; return s } } t.error("ERROR: MISSING PLUGIN (" + e + ") DEFINITION NOT FOUND") } }, dependencyFactoryInterceptor: function () { return function (e, t) { var n = undefined; if (t) { for (var r = 0; r < t.length; r++) { if (t[r].name === e) { n = t[r].dependency } } } return n } }(), dependencyInjectorFactory: function (e, n, r, i) { t.log(" invoking plugin....   " + o[e].name); var f = o[e].dependency; var l = f.length; t.log("injecting dependencies....   "); t.log(o[e].dependency.toString() || " ***Oh! No available dependency"); t.log("finally executing  " + o[e].name + " ....."); var c = s(r, i); n = n || {}; var h = o.length; for (var p = 0; p < l; p++) { var d = f[p]; var v = this.dependencyFactoryInterceptor(d, c); if (v === undefined) { for (var m = 0; m < h; m++) { var g = o[m]; var y = this.getModuleDependencies(u); var b = this.getMockObject(d); var w = {}; if (this.enableMocking && typeof b === "function") { w = b(); n[d] = w } else { w = g.that.using(g.name); if (g.name === d && g.module === a) { n[g.name] = g.autoExecute ? w.WithArguments(i).execute() : w } else { if (y && y.length && y.indexOf(g.name)) { n[g.name] = g.autoExecute ? w.WithArguments(i).execute() : w } } } } } else { n[d] = v } } return n }, getModuleDependencies: function (n) { if (n && n.length !== 0) { for (var r = 0; r < n.length; r++) { var i = n[r]; var s = e.isosceles.namespaces[f]; if (s) { var o = s.module(i).myDependencies(); if (o && o.length == 0) { t.error("Dependency '" + n + "'  has NOT been added to the namespace '" + f + "' and cannot be injected into '" + a + "'") } return o } } } }, myDependency: function (e) { for (var t = 0; t < o.length; t++) { if (o[t].name === e && o[t].module === a && o[t].namespace === f) { return o[t].plugin } } }, myDependencies: function () { var e = []; for (var t = 0; t < o.length; t++) { if (o[t].module === a && o[t].namespace === f) { e.push(o[t].name) } } return e }, plugin: function (e, n, r, i, s) { var u = s || "NONE provider"; t.log("--->Registering a " + u + "  " + e + "  ...."); var l = typeof n === "function" ? n : r || function () { }; var c = Object.prototype.toString.call(n) === "[object Array]" ? n : []; if (typeof l === "function" && e) { o.push({ namespace: f, module: a, name: e, plugin: l, dependency: c, that: this, nature: u, autoExecute: i }) } }, provider: function (e, t, n) { this.plugin(e, t, n, "PROVIDER") } }; r[i][a] = p; return r[i][a] }; e.isosceles.namespaces[i] = new u; return e.isosceles.namespaces[i] } }; e.isosceles.api = t || function () { }; var i = isosceles("_$n_"); e.isosceles.module = i.module; var s = i.module("_$m_"); for (var o in s) { if (s.hasOwnProperty(o)) { e.isosceles[o] = s[o] } } e.iso = e.isosceles })(window, undefined)
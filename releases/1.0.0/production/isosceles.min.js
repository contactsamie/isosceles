/*! isosceles.js v1.0.0 | (c) 2013, Samuel Bamgboye*/
/**
 * isosceles v1.0.0 - Cleaner JavaScript Dependency Injection Factory
 *
 * Copyright 2013 Samuel Bamgboye
 * Released under the MIT license.
 */
(function (e) { function t() { t.counter = t.counter || 0; t.counter++; return "siddis" + t.counter } var n = {}; e.isosceles = function (t, r) { n[t] = []; var i = n[t]; if (t) { e.isosceles.namespaces = {}; if (typeof r !== "function") { r = function () { return [] } } var s = function () { }; s.prototype.module = function (n, s) { var o = n; var u = t.toString(); s = s || []; return { using: function (e) { if (e) { var t = i.length; console.log("searching for plugin   " + e + " in pile ......"); for (var n = 0; n < t; n++) { if (i[n].name === e) { var r = this; console.log("found plugin   " + e + "! now returning ... "); return { WithArguments: function (e, t) { return { execute: function (s) { var o = {}; r.dependencyInjectorFactory(n, o, s, e); var u = typeof t === "function" ? t : function () { }; return i[n].plugin(o)(e, u) } } } } } } console.error("ERROR: MISSING PLUGIN (" + e + ") DEFINITION NOT FOUND") } }, dependencyFactoryInterceptor: function () { return function (e, t) { var n = undefined; if (t) { for (var r = 0; r < t.length; r++) { if (t[r].name === e) { n = t[r].dependency } } } return n } }(), dependencyInjectorFactory: function (e, t, n, u) { console.log(" invoking plugin....   " + i[e].name); var a = i[e].dependency; var f = a.length; console.log("injecting dependencies....   "); console.log(i[e].dependency.toString() || " ***Oh! No available dependency"); console.log("finally executing  " + i[e].name + " ....."); var l = r(n, u); t = t || {}; var c = i.length; for (var h = 0; h < f; h++) { var p = a[h]; var d = this.dependencyFactoryInterceptor(p, l); if (d === undefined) { for (var v = 0; v < c; v++) { var m = i[v]; var g = this.getModuleDependencies(s); if (m.name === p && m.module === o || g && g.length && g.indexOf(m.name)) { var y = m.that.using(m.name); t[m.name] = m.autoExecute ? y.WithArguments(u).execute() : y } } } else { t[p] = d } } return t }, getModuleDependencies: function (t) { if (t) { for (var n = 0; n < t.length; n++) { var r = t[n]; var i = e.isosceles.namespaces[u]; if (i) { return i.module(r).myDependencies() } } } }, myDependency: function (e) { for (var t = 0; t < i.length; t++) { if (i[t].name === e && i[t].module === o && i[t].namespace === u) { return i[t].plugin } } }, myDependencies: function () { var e = []; for (var t = 0; t < i.length; t++) { if (i[t].module === o && i[t].namespace === u) { e.push(i[t].name) } } return e }, plugin: function (e, t, n, r, s) { var a = s || "NONE provider"; console.log("--->Registering a " + a + "  " + e + "  ...."); var f = typeof t === "function" ? t : n || function () { }; var l = Object.prototype.toString.call(t) === "[object Array]" ? t : []; if (typeof f === "function" && e) { i.push({ namespace: u, module: o, name: e, plugin: f, dependency: l, that: this, nature: a, autoExecute: r }) } }, provider: function (e, t, n) { this.plugin(e, t, n, "PROVIDER") } } }; e.isosceles.namespaces[t] = new s; return e.isosceles.namespaces[t] } }; var r = t(); var i = t(); e.isosceles.module = isosceles(r).module; var s = e.isosceles.module(i); e.isosceles.module.plugin = s.plugin; e.isosceles.module.using = s.using; e.isosceles.dependencyInjectorFactory; e.isosceles.using = e.isosceles.module.using; e.isosceles.plugin = e.isosceles.module.plugin; e.iso = e.isosceles })(window, undefined)
/*! isosceles.js v1.0.0 | (c) 2013, Samuel Bamgboye*/
/**
 * isosceles v1.0.1 - Cleaner JavaScript Dependency Injection Factory
 *
 * Copyright 2013 Samuel Bamgboye
 * Released under the MIT license.
 */
(function (e) { var t = {}; e.isosceles = function (n, r) { t[n] = []; var i = t[n]; if (n) { e.isosceles.namespaces = e.isosceles.namespaces || {}; if (typeof r !== "function") { r = function () { return [] } } var s = function () { }; s.prototype.module = function (t, s) { var o = t; var u = n.toString(); s = s || []; return { using: function (e) { if (e) { var t = i.length; console.log("searching for plugin   " + e + " in pile ......"); for (var n = 0; n < t; n++) { if (i[n].name === e) { var r = this; console.log("found plugin   " + e + "! now returning ... "); var s = function (e, t, n) { return s.WithArguments(e, t).execute(n || undefined) }; s.WithArguments = function (e, t) { return { execute: function (s) { var o = {}; r.dependencyInjectorFactory(n, o, s, e); var u = typeof t === "function" ? t : function () { }; return i[n].plugin(o)(e, u) } } }; return s } } console.error("ERROR: MISSING PLUGIN (" + e + ") DEFINITION NOT FOUND") } }, dependencyFactoryInterceptor: function () { return function (e, t) { var n = undefined; if (t) { for (var r = 0; r < t.length; r++) { if (t[r].name === e) { n = t[r].dependency } } } return n } }(), dependencyInjectorFactory: function (e, t, n, u) { console.log(" invoking plugin....   " + i[e].name); var a = i[e].dependency; var f = a.length; console.log("injecting dependencies....   "); console.log(i[e].dependency.toString() || " ***Oh! No available dependency"); console.log("finally executing  " + i[e].name + " ....."); var l = r(n, u); t = t || {}; var c = i.length; for (var h = 0; h < f; h++) { var p = a[h]; var d = this.dependencyFactoryInterceptor(p, l); if (d === undefined) { for (var v = 0; v < c; v++) { var m = i[v]; var g = this.getModuleDependencies(s); if (m.name === p && m.module === o) { var y = m.that.using(m.name); t[m.name] = m.autoExecute ? y.WithArguments(u).execute() : y } else { if (g && g.length && g.indexOf(m.name)) { var y = m.that.using(m.name); t[m.name] = m.autoExecute ? y.WithArguments(u).execute() : y } } } } else { t[p] = d } } return t }, getModuleDependencies: function (t) { if (t) { for (var n = 0; n < t.length; n++) { var r = t[n]; var i = e.isosceles.namespaces[u]; if (i) { var s = i.module(r).myDependencies(); return s } } } }, myDependency: function (e) { for (var t = 0; t < i.length; t++) { if (i[t].name === e && i[t].module === o && i[t].namespace === u) { return i[t].plugin } } }, myDependencies: function () { var e = []; for (var t = 0; t < i.length; t++) { if (i[t].module === o && i[t].namespace === u) { e.push(i[t].name) } } return e }, plugin: function (e, t, n, r, s) { var a = s || "NONE provider"; console.log("--->Registering a " + a + "  " + e + "  ...."); var f = typeof t === "function" ? t : n || function () { }; var l = Object.prototype.toString.call(t) === "[object Array]" ? t : []; if (typeof f === "function" && e) { i.push({ namespace: u, module: o, name: e, plugin: f, dependency: l, that: this, nature: a, autoExecute: r }) } }, provider: function (e, t, n) { this.plugin(e, t, n, "PROVIDER") } } }; e.isosceles.namespaces[n] = new s; return e.isosceles.namespaces[n] } }; var n = isosceles("_$n_"); e.isosceles.module = n.module; var r = n.module("_$m_"); for (var i in r) { if (r.hasOwnProperty(i)) { e.isosceles[i] = r[i] } } e.iso = e.isosceles })(window, undefined)